<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>昼夜が分かる3D地球儀</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="loading">テクスチャを読み込み中...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, globe;
        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;

        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;

            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.3);
            scene.add(ambientLight);

            // SVGを高解像度で読み込む
            loadHighResSVGTexture('earth.svg');
        }

        function loadHighResSVGTexture(url) {
            // SVGを読み込む
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('earth.svgが見つかりません');
                    }
                    return response.text();
                })
                .then(svgText => {
                    // SVGをImageオブジェクトとして読み込む
                    const img = new Image();
                    const svg = new Blob([svgText], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(svg);
                    
                    img.onload = function() {
                        // 高解像度でCanvasにラスタライズ（4096x2048ピクセル）
                        const canvas = document.createElement('canvas');
                        const targetWidth = 4096;  // 高解像度
                        const targetHeight = 2048;
                        canvas.width = targetWidth;
                        canvas.height = targetHeight;
                        
                        const ctx = canvas.getContext('2d');
                        // 高品質な描画設定
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        
                        // SVGを描画
                        ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
                        
                        URL.revokeObjectURL(url);
                        
                        // Canvasからテクスチャを作成
                        const texture = new THREE.CanvasTexture(canvas);
                        
                        // テクスチャの品質設定
                        texture.minFilter = THREE.LinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                        texture.needsUpdate = true;
                        
                        document.getElementById('loading').style.display = 'none';
                        createGlobe(texture);
                        setupEventListeners();
                        animate();
                    };
                    
                    img.onerror = function() {
                        document.getElementById('loading').textContent = 'テクスチャの読み込みに失敗しました';
                    };
                    
                    img.src = url;
                })
                .catch(error => {
                    console.error('エラー:', error);
                    document.getElementById('loading').textContent = 'earth.svgが見つかりません。同じフォルダに配置してください。';
                });
        }

        function createGlobe(texture) {
            // より高解像度の球体ジオメトリ
            const geometry = new THREE.SphereGeometry(1, 256, 256);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    earthTexture: { value: texture },
                    sunDirection: { value: new THREE.Vector3() },
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D earthTexture;
                    uniform vec3 sunDirection;
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        // テクスチャから色を高品質で取得
                        vec4 texColor = texture2D(earthTexture, vUv);
                        
                        // グレースケール化（陸地と海の判定用）
                        float brightness = (texColor.r + texColor.g + texColor.b) / 3.0;
                        
                        // 太陽光の計算
                        vec3 normal = normalize(vNormal);
                        float sunDot = dot(normal, normalize(sunDirection));
                        
                        // 昼夜の境界をスムーズに
                        float dayNight = smoothstep(-0.05, 0.05, sunDot);
                        
                        // 昼間: テクスチャの色をそのまま使用
                        // 夜間: 色を反転（白→黒、黒→白）
                        vec3 dayColor = vec3(brightness);
                        vec3 nightColor = vec3(1.0 - brightness);
                        
                        vec3 color = mix(nightColor, dayColor, dayNight);
                        
                        // 球体の縁を少し暗く（立体感）
                        float fresnel = pow(1.0 - abs(dot(normal, normalize(vec3(0, 0, 1)))), 1.5);
                        color *= 1.0 - fresnel * 0.2;
                        
                        // 薄明の色味を追加
                        if(sunDot > -0.2 && sunDot < 0.2) {
                            float twilightFactor = 1.0 - abs(sunDot) / 0.2;
                            vec3 twilightColor = vec3(0.4, 0.5, 0.7) * twilightFactor * 0.3;
                            color += twilightColor;
                        }
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });

            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);
        }

        function updateSunDirection() {
            if (!globe) return;
            
            const now = new Date();
            const hours = now.getUTCHours();
            const minutes = now.getUTCMinutes();
            const seconds = now.getUTCSeconds();
            
            const timeInHours = hours + minutes / 60 + seconds / 3600;
            const angle = (timeInHours / 24) * Math.PI * 2 - Math.PI;
            
            const sunDirection = new THREE.Vector3(
                Math.cos(angle),
                0,
                Math.sin(angle)
            );
            
            globe.material.uniforms.sunDirection.value = sunDirection;
        }

        function setupEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseDown(e) {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (mouseDown) {
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        }

        function onMouseUp() {
            mouseDown = false;
        }

        function onWheel(e) {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.002;
            camera.position.z = Math.max(1.5, Math.min(6, camera.position.z));
        }

        let lastTouchX = 0, lastTouchY = 0;
        let lastTouchDistance = 0;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - lastTouchX;
                const deltaY = e.touches[0].clientY - lastTouchY;
                
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
                
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const delta = distance - lastTouchDistance;
                camera.position.z -= delta * 0.01;
                camera.position.z = Math.max(1.5, Math.min(6, camera.position.z));
                
                lastTouchDistance = distance;
            }
        }

        function onTouchEnd() {
            lastTouchDistance = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!globe) return;

            updateSunDirection();

            // 自動回転（ゆっくり）
            if (!mouseDown) {
                targetRotationY += 0.001;
            }

            // スムーズな回転
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;

            globe.rotation.x = currentRotationX;
            globe.rotation.y = currentRotationY;

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>